#!/usr/bin/env escript
%% -*- mode: erlang;erlang-indent-level: 4;indent-tabs-mode: nil -*-
%% ex: ft=erlang ts=4 sw=4 et
%% -------------------------------------------------------------------
%%
%% nodetool: Helper Script for interacting with live nodes
%%
%% -------------------------------------------------------------------
-define(RPC_TIMEOUT, 60 * 1000). %% 1 minute

main(Args0) ->
    ok = start_epmd(),
    %% Extract the args
    {Args, TargetNode} = process_args(Args0),
    Action = get_arg("action", Args),

    %% any commands that don't need a running node
    case Action of
        "chkconfig" ->
            File = get_arg("file", Args),
            case file:consult(File) of
                {ok, _} ->
                    success("ok");
                {error, {Line, Mod, Term}} ->
                    Error = file:format_error({Line, Mod, Term}),
                    fail("Error on line ~s", [Error]);
                {error, R} ->
                    Error = file:format_error(R),
                    fail("Error reading config file: ~s", [Error])
            end;
        _ ->
            ok
    end,

    %% See if the node is currently running  -- if it's not, we'll bail
    case {net_kernel:hidden_connect_node(TargetNode),
          net_adm:ping(TargetNode)} of
        {true, pong} ->
            ok;
        {false,pong} ->
            fail(io_lib:format("Failed to connect to node ~p", [TargetNode]));
        {_, pang} ->
            fail(io_lib:format("Node ~p not responding to pings.", [TargetNode]))
    end,

    case Action of
        "getpid" ->
            success("~p",
                      [list_to_integer(rpc:call(TargetNode, os, getpid, []))]);
        "ping" ->
            %% If we got this far, the node already responsed to a
            %% ping, so just dump a "pong"
            success("pong");
        "stop" ->
            rpc(TargetNode, init, stop, [], Args);
        "restart" ->
            rpc(TargetNode, init, restart, [], Args);
        "reboot" ->
            rpc(TargetNode, init, reboot, [], Args);
        "eval" ->
            Command = get_arg("command", Args, "") ++ ".",
            case erl_scan:string(Command) of
                {ok, Tokens, _} ->
                    case erl_parse:parse_exprs(Tokens) of
                        {ok, Exprs} ->
                            rpc(TargetNode, erl_eval, exprs, [Exprs, []], Args);
                        {error, Reason} ->
                            Msg = format_parse_error(Reason),
                            fail(Msg)
                    end;
                {error, Reason, _} ->
                    Msg = format_parse_error(Reason),
                    fail(Msg)
            end;
        _Other ->
            fail("Wrong usage")
    end,
    net_kernel:stop().

process_args(Args) ->
    process_args(Args, [], undefined).

process_args([], Acc, TargetNode) ->
    {Acc, TargetNode};
process_args([H|T], Acc, TargetNode) ->
    case string:tokens(H, [$=]) of
        ["cookie", Cookie] ->
            erlang:set_cookie(node(), list_to_atom(Cookie)),
            process_args(T, [{"cookie", Cookie}|Acc], TargetNode);
        ["name", TargetName] ->
            ThisNode = append_node_suffix(TargetName, "_maint_"),
            {ok, _} = net_kernel:start([ThisNode, longnames]),
            process_args(T, [{"name", TargetName}|Acc], nodename(TargetName));
        ["sname", TargetName] ->
            ThisNode = append_node_suffix(TargetName, "_maint_"),
            {ok, _} = net_kernel:start([ThisNode, shortnames]),
            process_args(T, [{"name", TargetName}|Acc], nodename(TargetName));
        [Key, Value] ->
            process_args(T, [{Key, Value}|Acc], TargetNode);
        _ ->
            process_args(T, Acc, TargetNode)
    end.

start_epmd() ->
    [] = os:cmd(epmd_path() ++ " -daemon"),
    ok.

epmd_path() ->
    ErtsBinDir = filename:dirname(escript:script_name()),
    Name = "epmd",
    case os:find_executable(Name, ErtsBinDir) of
        false ->
            case os:find_executable(Name) of
                false ->
                    io:format("Could not find epmd.~n"),
                    halt(1);
                GlobalEpmd ->
                    GlobalEpmd
            end;
        Epmd ->
            Epmd
    end.


nodename(Name) ->
    case string:tokens(Name, "@") of
        [_Node, _Host] ->
            list_to_atom(Name);
        [Node] ->
            [_, Host] = string:tokens(atom_to_list(node()), "@"),
            list_to_atom(lists:concat([Node, "@", Host]))
    end.

append_node_suffix(Name, Suffix) ->
    case string:tokens(Name, "@") of
        [Node, Host] ->
            list_to_atom(lists:concat([Node, Suffix, os:getpid(), "@", Host]));
        [Node] ->
            list_to_atom(lists:concat([Node, Suffix, os:getpid()]))
    end.

success(String) ->
    success(String, []).

success(String, Args) ->
    Msg = lists:flatten(io_lib:format(String, Args)),
    io:format("{\"changed\": true, \"msg\": ~p}", [Msg]),
    halt(0).

fail(String) ->
    fail(String, []).

fail(String, Args) ->
    Msg = lists:flatten(io_lib:format(String, Args)),
    io:format("{\"failed\" : true, \"msg\": ~p}", [Msg]),
    halt(1).

format_parse_error({_Line, Mod, Err}) ->
    lists:flatten(Mod:format_error(Err)).

get_arg(Key, Args) ->
    get_arg(Key, Args, undefined).

get_arg(Key, Args, Default) ->
    proplists:get_value(Key, Args, Default).

rpc(Node, Mod, Fun, Args, Opts) ->
    Timeout = get_arg("rpc_timeout", Opts, ?RPC_TIMEOUT),
    case rpc:call(Node, Mod, Fun, Args, Timeout) of
        {badrpc, Reason} ->
            fail("RPC to ~p failed: ~p", [Node, Reason]);
        {value, Result, _} -> %% From erl_eval
            success("~p", [Result]);
        Result ->
            success("~p", [Result])
    end.
